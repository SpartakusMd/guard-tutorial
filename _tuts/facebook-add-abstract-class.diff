diff --git a/src/AppBundle/Security/AbstractSocialAuthenticator.php b/src/AppBundle/Security/AbstractSocialAuthenticator.php
new file mode 100644
index 0000000..3237790
--- /dev/null
+++ b/src/AppBundle/Security/AbstractSocialAuthenticator.php
@@ -0,0 +1,156 @@
+<?php
+
+namespace AppBundle\Security;
+
+use League\OAuth2\Client\Provider\AbstractProvider;
+use League\OAuth2\Client\Provider\Exception\IdentityProviderException;
+use League\OAuth2\Client\Provider\ResourceOwnerInterface;
+use League\OAuth2\Client\Token\AccessToken;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
+use Symfony\Component\Security\Core\User\UserInterface;
+use Symfony\Component\Security\Core\User\UserProviderInterface;
+use Symfony\Component\Security\Guard\AbstractGuardAuthenticator;
+
+abstract class AbstractSocialAuthenticator extends AbstractGuardAuthenticator
+{
+    /**
+     * Return the specific "provider" class you want to
+     * use from league/oauth2-client.
+     *
+     * @return AbstractProvider
+     */
+    abstract protected function getOAuth2Provider();
+
+    /**
+     * If true, the authenticator will look for the ?code= query
+     * parameter and attempt authentication. Typically, you'll
+     * check to see if the user is at the "redirect URI".
+     *
+     * For example, if you redirect to Facebook and have configure
+     * the provider to redirect the user back to /facebook/check,
+     * then you might have:
+     *
+     *   return $request->getPathInfo() == '/facebook/check';
+     *
+     * This will cause this authenticator to work its magic only
+     * when the URL matches this path.
+     *
+     * @return bool Return true if we should try to authenticate
+     */
+    abstract protected function shouldAttemptAuthentication(Request $request);
+
+    /**
+     * Return your User object based on the given information
+     *
+     * The $resourceOwner can be thought of as the special "User"
+     * object that contains information about the user's Facebook/Github
+     * account. In fact, most OAuth2 provider libraries return
+     * a custom class with specific information. For example, for
+     * the Facebook provider, $resourceOwner is an instance of
+     * League\OAuth2\Client\Provider\FacebookUser.
+     *
+     * Assuming Facebook and a User Doctrine entity, your code might be:
+     *
+     *   $email = $resourceOwner->getEmail();
+     *   return $this->em->getRepository('AppBundle:User')
+     *       ->findOneBy(['email' => $email]);
+     *
+     * @param ResourceOwnerInterface $resourceOwner
+     * @param AccessToken $accessToken
+     * @return UserInterface
+     */
+    abstract protected function getUserFromResourceOwner(ResourceOwnerInterface $resourceOwner, AccessToken $accessToken);
+
+    public function getCredentials(Request $request)
+    {
+        if (!$this->shouldAttemptAuthentication($request)) {
+            return null;
+        }
+
+        if ($code = $request->query->get('code')) {
+            return $code;
+        }
+
+        $this->onOAuth2ServerAuthorizationFailure($request);
+    }
+
+    public function getUser($authorizationCode, UserProviderInterface $userProvider)
+    {
+        $accessToken = $this->getAccessToken($authorizationCode);
+        $oAuth2User = $this->getOAuth2Provider()->getResourceOwner($accessToken);
+
+        return $this->getUserFromResourceOwner($oAuth2User, $accessToken);
+    }
+
+    public function checkCredentials($credentials, UserInterface $user)
+    {
+        // do nothing - the fact that the access token works is enough
+        return true;
+    }
+
+    /**
+     * This method is called when the user was redirected back to
+     * *without* a ?code= query parameter. This might mean the user
+     * denied access to your application or something else went wrong.
+     *
+     * To fail authentication, throw any AuthenticationException -
+     * as is done below. Like normal, this will cause
+     * onAuthenticationFailure() to ultimately be called.
+     *
+     * To do nothing and simply skip authentication, just return null.
+     *
+     * @param Request $request
+     */
+    protected function onOAuth2ServerAuthorizationFailure(Request $request)
+    {
+        // no code! Something went wrong. Quite probably the user denied our app access
+        // you could read the error, error_code, error_description, error_reason query params
+        // http://localhost:8000/connect/facebook-check?error=access_denied&error_code=200&error_description=Permissions+error&error_reason=user_denied&state=S2fKgHJSZSJM0Qs2fhKL6USZP50KSBHc#_=_
+        // todo - we should do better
+        throw new CustomUserMessageAuthenticationException(
+            'There was an error getting authenticating - did you deny access? Please try again.'
+        );
+    }
+
+    /**
+     * @param string $authorizationCode
+     * @return \League\OAuth2\Client\Token\AccessToken
+     */
+    protected function getAccessToken($authorizationCode)
+    {
+        try {
+            // the credentials are really the access token
+            return $this->getOAuth2Provider()->getAccessToken(
+                'authorization_code',
+                ['code' => $authorizationCode]
+            );
+        } catch (IdentityProviderException $e) {
+            $this->onAccessTokenRequestFailure($e);
+
+            // in case you're being a bugger and don't throw an exception above :)
+            throw new \LogicException('The system failed to exchange the authorization code for an access token. Your onAccessTokenRequestFailure() must throw an exception', 0, $e);
+        }
+    }
+
+    /**
+     * This is called when the authorization code could not be exchanged
+     * for an access token.
+     *
+     * You should throw your own AuthenticationException from this
+     * method (which will trigger onAuthenticationFailure, like normal)
+     *
+     * @param IdentityProviderException $e
+     */
+    protected function onAccessTokenRequestFailure(IdentityProviderException $e)
+    {
+        // probably the authorization code has been used already
+        $response = $e->getResponseBody();
+        $errorCode = $response['error']['code'];
+        $message = $response['error']['message'];
+
+        throw new CustomUserMessageAuthenticationException(
+            'There was an accessing your account. Please try again'
+        );
+    }
+}
diff --git a/src/AppBundle/Security/FacebookAuthenticator.php b/src/AppBundle/Security/FacebookAuthenticator.php
index e23c042..dc8407f 100644
--- a/src/AppBundle/Security/FacebookAuthenticator.php
+++ b/src/AppBundle/Security/FacebookAuthenticator.php
@@ -4,23 +4,20 @@ namespace AppBundle\Security;
 
 use AppBundle\Entity\User;
 use Doctrine\ORM\EntityManager;
-use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
-use League\OAuth2\Client\Provider\Exception\IdentityProviderException;
+use League\OAuth2\Client\Provider\AbstractProvider;
+use League\OAuth2\Client\Provider\ResourceOwnerInterface;
+use League\OAuth2\Client\Token\AccessToken;
 use League\OAuth2\Client\Provider\Facebook;
 use League\OAuth2\Client\Provider\FacebookUser;
-use Symfony\Component\DependencyInjection\ContainerInterface;
 use Symfony\Component\HttpFoundation\RedirectResponse;
-use Symfony\Component\HttpFoundation\Response;
 use Symfony\Component\Routing\RouterInterface;
 use Symfony\Component\Security\Core\Security;
-use Symfony\Component\Security\Guard\AbstractGuardAuthenticator;
 use Symfony\Component\HttpFoundation\Request;
 use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
 use Symfony\Component\Security\Core\Exception\AuthenticationException;
 use Symfony\Component\Security\Core\User\UserInterface;
-use Symfony\Component\Security\Core\User\UserProviderInterface;
 
-class FacebookAuthenticator extends AbstractGuardAuthenticator
+class FacebookAuthenticator extends AbstractSocialAuthenticator
 {
     /**
      * @var Facebook
@@ -42,46 +39,31 @@ class FacebookAuthenticator extends AbstractGuardAuthenticator
         $this->router = $router;
     }
 
-    public function getCredentials(Request $request)
+    /**
+     * @return AbstractProvider
+     */
+    protected function getOAuth2Provider()
     {
-        if ($request->getPathInfo() != '/connect/facebook-check') {
-            // skip authentication unless we're on this URL!
-            return null;
-        }
-
-        if ($code = $request->query->get('code')) {
-            return $code;
-        }
-
-        // no code! Something went wrong. Quite probably the user denied our app access
-        // you could read the error, error_code, error_description, error_reason query params
-        // http://localhost:8000/connect/facebook-check?error=access_denied&error_code=200&error_description=Permissions+error&error_reason=user_denied&state=S2fKgHJSZSJM0Qs2fhKL6USZP50KSBHc#_=_
-        throw new CustomUserMessageAuthenticationException(
-            'There was an error getting access from Facebook. Please try again.'
-        );
+        return $this->facebook;
     }
 
-    public function getUser($authorizationCode, UserProviderInterface $userProvider)
+    /**
+     * @return bool Return true if we should try to authenticate
+     */
+    protected function shouldAttemptAuthentication(Request $request)
     {
-        try {
-            // the credentials are really the access token
-            $accessToken = $this->facebook->getAccessToken(
-                'authorization_code',
-                ['code' => $authorizationCode]
-            );
-        } catch (IdentityProviderException $e) {
-            // probably the authorization code has been used already
-            $response = $e->getResponseBody();
-            $errorCode = $response['error']['code'];
-            $message = $response['error']['message'];
-
-            throw new CustomUserMessageAuthenticationException(
-                'There was an error logging you into Facebook - code '.$errorCode
-            );
-        }
+        return $request->getPathInfo() == '/connect/facebook-check';
+    }
 
+    /**
+     * @param ResourceOwnerInterface $resourceOwner
+     * @param AccessToken $accessToken
+     * @return UserInterface
+     */
+    protected function getUserFromResourceOwner(ResourceOwnerInterface $resourceOwner, AccessToken $accessToken)
+    {
         /** @var FacebookUser $facebookUser */
-        $facebookUser = $this->facebook->getResourceOwner($accessToken);
+        $facebookUser = $resourceOwner;
         $email = $facebookUser->getEmail();
 
         // 1) have they logged in with Facebook before? Easy!
@@ -114,12 +96,6 @@ class FacebookAuthenticator extends AbstractGuardAuthenticator
         return $user;
     }
 
-    public function checkCredentials($credentials, UserInterface $user)
-    {
-        // do nothing - the fact that the access token worked means that
-        // our app has been authorized with Facebook
-    }
-
     public function onAuthenticationFailure(Request $request, AuthenticationException $exception)
     {
         // this would happen if something went wrong in the OAuth flow
